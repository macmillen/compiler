/*
 * parser.cup -- SPL parser specification
 */


package parse;

import java_cup.runtime.*;
import sym.*;
import absyn.*;

/* Preliminaries to set up and use the scanner.  */
/*
init with {: scanner.init();              :};
scan with {: return scanner.next_token(); :};
*/
parser code {:

  public void syntax_error(Symbol currToken) {
    System.out.println(
      "**** Error: syntax error" +
      " in line " + currToken.left +
      ", column " + currToken.right
    );
    System.exit(0);
  }

:}

/* Terminals (tokens returned by the scanner). */
terminal			ARRAY, ELSE, IF, OF, PROC, REF, TYPE, VAR, WHILE, LPAREN, RPAREN, LBRACK,
					RBRACK, LCURL, RCURL, EQ, NE, LT, LE, GT, GE, ASGN, COLON, COMMA, SEMIC, PLUS,
					MINUS, STAR, SLASH;
terminal Integer	INTLIT;
terminal String		IDENT;


/* Non-terminals */

non terminal        DecList program;
non terminal	    TypeDec typedef;
non terminal		Ty type;
non terminal		ProcDec procedure;
non terminal		CallStm procedure_call;
non terminal		ParDec parameter;
non terminal		DecList parameterList;
non terminal		DecList paramListTail;
non terminal		Exp argument;
non terminal		ExpList argumentList;
non terminal		ExpList argumentListTail;
non terminal		VarDec vardec;
non terminal		VarDec vardecs;
non terminal		AssignStm varassign;
non terminal		WhileStm while_statement;
non terminal		IfStm if_statement;
non terminal		Stm statement;
non terminal		StmList statements;
non terminal		Exp refExpression;
non terminal		Exp expression;
non terminal		Exp simple_expression;
non terminal		Exp term;
non terminal		Exp unary;
non terminal		Exp factor;
non terminal		Exp number;

start with program;

program			        ::= typedef:type program:prog {:RESULT = new DecList(type, prog);:} | procedure program {:RESULT = ;:} | {:RESULT = new DecList();:} 
    ;
typedef                 ::= TYPE IDENT EQ type SEMIC
    ;
type                    ::= IDENT:ident 
                            {:RESULT = new VarExp(identleft, identright, new SimpleVar(identleft, identright, newSym(ident)));:}| {:RESULT = ...;:} //Ohne Gew√§hr
                            ARRAY LBRACK INTLIT RBRACK OF type
    ;
procedure               ::= PROC IDENT:ident {:RESULT = new ProcDec(identleft, identright, newSym(ident), params, decls, stmts);:}
                            LPAREN parameterList:params RPAREN LCURL vardecs:decls statements:stmts RCURL
    ;
procedure_call          ::= IDENT LPAREN argumentList:expList RPAREN SEMIC {:RESULT = new CallStm(identleft, identright, newSym(ident), expList);:}
    ;
parameterList 			::= {:RESULT = new DecList();:} | parameter:dec paramListTail:decList {:RESULT = new DecList(dec, decList);:}
	;
parameter 				::= IDENT:ident COLON type:typ {:RESULT = new ParDec(identleft, identright, newSym(ident), typ, false);:} |
                            REF IDENT:ident COLON type:typ {:RESULT = new ParDec(identleft, identright, newSym(ident), typ, true);:}
	;
paramListTail 			::= | COMMA parameter paramListTail
	;
argument 				::= expression:expr
                            {:RESULT = expr;:}
	;
argumentList			::= |  argumentListTail
	;
argumentListTail 		::= argument | argument COMMA argumentListTail
	;

vardec                  ::= VAR IDENT COLON type SEMIC
    ;
vardecs					::= vardec vardecs |
	;
varassign               ::= refExpression ASGN expression SEMIC
    ;
while_statement         ::= WHILE LPAREN expression RPAREN statement
    ;   
if_statement            ::= IF LPAREN expression RPAREN statement |
                            IF LPAREN expression RPAREN statement ELSE statement
    ;
statement               ::= varassign | procedure_call | if_statement | while_statement | SEMIC | LCURL statements RCURL
    ;
statements				::= statement statements | 
	;

refExpression 			::= IDENT | refExpression LBRACK expression RBRACK
	;
expression              ::= simple_expression EQ simple_expression 
                            {:RESULT = new OpExp(pos1, pos2, operator, op1, op2);:}
							|
                            simple_expression NE simple_expression |
							simple_expression LT simple_expression |
							simple_expression LE simple_expression |
							simple_expression GT simple_expression |
							simple_expression GE simple_expression |
							simple_expression
    ; 
simple_expression       ::= term | term PLUS simple_expression | term MINUS simple_expression
    ;
term                    ::= unary | unary STAR term | unary SLASH term
    ;
unary 					::= factor | MINUS factor 
	;
factor                  ::= refExpression | number | LPAREN expression RPAREN
    ;
number					::= INTLIT
	;